package main

import (
	"log"
	"os"

	"github.com/Yandex-Practicum/go1fl-sprint6-final/internal/server"
)

func main() {
	
	// создаём файл info.log и обрабатываем ошибку, если что-то пошло не так
	file, err := os.OpenFile("info.log", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatal(err)
      
	}
	// откладываем закрытие файла
	defer file.Close()
	//1й аргумент: устанавливаем вывод в file, 2й аргумент: префикс-""(.....), 3й аргумент: формат вывода в файл
	logger := log.New(file, ".....", log.Ldate|log.Ltime|log.Lshortfile)
	
	//  Вызываем сервер Myserver , передаем созданный логгер, получаем экземпляр сервера и настраиваем его
	Srv := server.Myserver(logger)
    // Запуск сервера
    err=Srv.HTTPServer.ListenAndServe() 
    if err != nil {
		// Если при запуске сервера возникают ошибки, выводим их с помощью логгера на уровне Fatal
		logger.Fatal("Ошибка при запуске сервера: ", err)
	}
}
package server

import (
	"log"
	"net/http"
	"time"
	"github.com/Yandex-Practicum/go1fl-sprint6-final/internal/handlers"
)

//Структура сервера
type Serv struct {
	loggerServ   *log.Logger
	HTTPServer   http.Server
}

func Myserver(logger *log.Logger) *Serv {
router := http.NewServeMux() // Маршрутизатор

// Регистрируем хэндлеры для различных путей
    
router.HandleFunc("/",  handlers.Handler1)    // вызов хэндлера по ....."/"      
    
router.HandleFunc("/upload", handlers.Handler2)  // вызов хэндлера по ....."/upload"

S:= &Serv{
	loggerServ: logger,
	HTTPServer: http.Server{
        Addr:         ":8080",
        Handler:      router,
        ErrorLog:     logger,
        ReadTimeout:  5 * time.Second,
        WriteTimeout: 10 * time.Second,
        IdleTimeout:  15 * time.Second,
    },
}
return S}
package handlers

import (
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/Yandex-Practicum/go1fl-sprint6-final/internal/service"
)

 var Logger *log.Logger
 // функция определения размера скачивания//////////////////////////////
/* func getFileSize(filePath string) (int64, error) {
    fileInfo, err := os.Stat(filePath)
    if err != nil {
        return 0, err
    }
    return fileInfo.Size(), nil
}*/
/////////////////////////////////////////////////////////////////////////////////////////////////
//Реализация хэндлера по запросу "/"        /////
func Handler1(res http.ResponseWriter, req *http.Request) {
 //  fileSize, err := getFileSize("C:\\Users\\Евгений\\Dev\\Sprint6-final\\Sprint6\\index.html")
//if err != nil {
    // Обработка ошибки
//    log.Fatal("Ошибка при получении размера файла:", err)
//} else {
//    Logger.Println("Размер файла:", fileSize, "байт")
//} 
//открыть файл 
data, err := os.ReadFile("C:\\Users\\Евгений\\Dev\\Sprint6-final\\Sprint6\\index.html")

    if err != nil{//&&len(data)!=int(fileSize) {
        Logger.Fatal(err)
    }
_, err = res.Write([]byte(data))

if err != nil{//&&len(data)!=n {
    // Обработка ошибки
    Logger.Fatal("Ошибка при записи данных:", err)
//} else {
//    Logger.Println("Было передано", n, "байтов")
}
}
///////////////////////////////////////////////////////////////////////////////////////////////////
// Реализация хэндлера по запросу "/upload"
func Handler2(res http.ResponseWriter, req *http.Request) {
// Парсинг формы//////////////////////////////////////////////////////////////////////////////////
      // if err := req.ParseForm(); err != nil {
      req.ParseMultipartForm(10 << 20) // 10 MB 
//       http.Error(res,"Ошибка при парсинге формы", http.StatusInternalServerError)
//        Logger.Fatal(err)
//        return
//    }
// Получение файла из формы////////////////////////////////////////////////////////////////////////////
    file,header, err := req.FormFile("myFile") // "myFile" - название поля файла в форме
    if err != nil { 
        http.Error(res, "Не удалось получить файл", http.StatusInternalServerError)
        Logger.Fatal(err)
        return
    }
    defer file.Close() //Закрываем файл/////
// Чтение данных из файла////////////////////
    data, err := io.ReadAll(file)
    if err != nil {
        http.Error(res, "Ошибка при чтении файла", http.StatusInternalServerError)
        Logger.Fatal(err)
        return
    }
//  конвертация строки//////////////////
   convString:=service.Texttomorse_and_revers(string(data))

// Создаем новый файл///////////////////
    now := time.Now()
    currentTime1 := now.String()[:11]
    currentTime2 := strings.ReplaceAll(now.String()[11:37], ":", "-", )
    fileExtantion := filepath.Ext(header.Filename)
    file2, err := os.Create(currentTime1+currentTime2+fileExtantion)       
    if err != nil {
        http.Error(res, "Ошибка при создании файла", http.StatusInternalServerError)
        Logger.Fatal(err)
    }
//Записываем результат конвертации строки в файл file2////
    _, err = file2.WriteString(convString)
    if err != nil {
         http.Error(res, "Ошибка при записи результата конвертации строки в файл", http.StatusInternalServerError)
        log.Fatal(err)
    }
defer file2.Close()
    _,err=res.Write([]byte(convString))
    if err !=   nil {
        http.Error(res, "Ошибка при передаче файла", http.StatusInternalServerError)
        Logger.Fatal(err)
    }
}
package service

import (
//	"fmt"

	"github.com/Yandex-Practicum/go1fl-sprint6-final/pkg/morse"
)

func Texttomorse_and_revers(str string) string {
	s1 := morse.ToText(str)
	s2 := morse.ToMorse(s1)
	if s2 == str {
    return morse.ToText(str)
	} else {	
		return morse.ToMorse(str)
	}
}
